#! /usr/bin/env node

if (!process.env.TASKCLUSTER_ROOT_URL) {
  throw new Error('Missing required environment variable TASKCLUSTER_ROOT_URL');
}

const stringify = require('javascript-stringify');
const { compile } = require('ejs');
const omit = require('object.omit');
const { readFileSync, writeFileSync } = require('fs');
const { join } = require('path');
const fetchApis = require('./fetch-apis');

const src = join(__dirname, '../src');
const template = compile(
  readFileSync(join(__dirname, '../templates/client.ejs'), 'utf-8')
);
const index = readFileSync(join(src, 'index.js'), 'utf-8');
// We won't need to dynamically generate the service name from the
// baseUrl when all APIs have reference.name.
// Allow for older schemas.
// This should be deleted once it is no longer used.
const getServiceName = reference => {
  if (reference.serviceName) {
    return reference.serviceName;
  }

  // It was called this for a while, see:
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1463207
  if (reference.name) {
    return reference.name;
  }

  if (reference.rootUrl) {
    const parts = reference.rootUrl.split('//');

    return (parts[1] || parts[0]).split('.')[0];
  }

  if (reference.exchangePrefix) {
    return reference.exchangePrefix.split('/')[1].replace('taskcluster-', '');
  }
};

fetchApis()
  .then(apis => {
    const exports = Object
      .keys(apis)
      .sort()
      .reduce((exports, name, index, context) => {
        const client = apis[name];
        const { reference } = client;

        writeFileSync(
          join(src, `clients/${name}.js`),
          template({
            name,
            stringify,
            omit,
            rootUrl: process.env.TASKCLUSTER_ROOT_URL,
            serviceName: getServiceName(reference),
            serviceVersion: 'v1',
            exchangePrefix: reference.exchangePrefix,
            methods: reference.entries
              .filter(({ type }) => type === 'function')
              .map(entry => {
                if (entry.input) {
                  entry.input = true;
                }

                if (entry.output) {
                  entry.output = true;
                }

                return entry;
              }),
            topics: reference.entries
              .filter(({ type }) => type === 'topic-exchange')
              .map(entry => Object.assign(entry, {
                routingKey: entry.routingKey.map(route => omit(route, ['summary']))
              }))
          }),
          { encoding: 'utf-8' }
        );

        return `${exports}export { default as ${name} } from './clients/${name}';${index === context.length - 1 ? '' : '\n'}`;
      }, '');

    writeFileSync(
      join(src, 'index.js'),
      index.replace(
        /\/\/ AUTOGENERATED-START([\s\S]*?)\/\/ AUTOGENERATED-END/gmi,
        `// AUTOGENERATED-START\n${exports}\n// AUTOGENERATED-END`
      ),
      { encoding: 'utf-8' }
    );
  })
  .catch(err => console.error(err));
